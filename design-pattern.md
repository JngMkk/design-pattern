## 디자인 패턴의 요소
---
디자인 패턴은 객체 지향 시스템에서 일련의 문제들을 해결하기 위해 반복되는 디자인 측면을 기록하기 위해 노력함.

- Name: 패턴을 설명할 때 잘 알려진 핸들이나 제목이 사용됨. 디자인 패턴에 표준적인 이름을 사용하면 의사소통이 쉽고 디자인 관련 어휘도 늘어남.
- Context: 컨텍스트는 문제가 발생하는 상황임. 컨텍스트는 웹 애플리케이션 소프트웨어 개발처럼 일반적인 상황이 될 수도 있고, Pub/Sub 시스템의 공유 메모리 구현 같은 자원 변경에 대한 알림 구현처럼 특화된 상황일 수도 있음.
- Problem: 패턴이 적용돼야 하는 실제 문제를 설명함. 문제는 다음 항목들로 설명할 수 있음.
	- Requirements: 요구사항은 솔루션이 반드시 만족해야 하는 사항. 예를 들어 Publisher-Subscriber 패턴의 구현은 반드시 HTTP를 지원해야 함.
	- Constraints: 솔루션의 제약사항임. 가령 확장 가능한 Peer-to-Peer 게시자 패턴은 알림을 게시하기 위해, 세 개 이상의 메시지를 교환해서는 안 됨.
	- Properties: 솔루션이 가져야 하는 속성. 예를 들어, 솔루션은 윈도우와 리눅스 플랫폼에서 동일하게 동작해야 함.
- Solution: 문제의 실제 해결책을 보여줌. 솔루션은 솔루션을 구성하는 요소들의 구조와 책임, 정적 관계와 런타임 시 상호작용을 기술함. 솔루션은 문제가 해결되는 방법도 설명해야 함. 솔루션은 결과도 언급해야 함. 다시 말해, 적용 패턴의 결과와 트레이드 오프에 관해서도 이야기해야 함.

## 디자인 패턴의 분류
---
디자인 패턴은 선택 기준에 따라 다양한 방법으로 분류할 수 있음. 일반적으로는 패턴의 목적을 기준으로 사용함. 즉, 패턴이 어떤 종류의 문제를 해결하는지 물음.

### Creational Pattern
---
객체의 생성과 초기화에 관련된 문제를 해결함. 이들은 수명주기에서 가장 먼저 발생하는 문제들로 객체와 클래스를 통해 문제를 해결함.
#### Singleton Pattern
'내가 생성하는 클래스의 인스턴스를 한 번만 생성하고 초기화하는 방법은 무엇인가?' 또는 '클래스의 모든 인스턴스들이 똑같은 초기 상태를 공유하는 방법은 무엇인가?'라는 질문은 싱글톤 패턴을 통해 해결할 수 있음.

**싱글톤은 오직 하나의 인스턴스와 잘 정의된 액세스 포인트를 갖는 클래스**
- 요구 사항
	- 클래스는 잘 알려진 액세스 포인트를 통해 접근 가능하며 단 하나의 인스턴스만 가져야 함.
	- 클래스는 패턴을 망치지 않으면서 상속을 통해 확장할 수 있어야 함.

**싱글톤이 왜 필요할까?**
싱글톤의 첫 번째 요구사항을 원래 구문과 약간 다른 방법으로 바꿔 보자.
'클래스는 모든 인스턴스가 같은 초기 상태를 공유하기 위한 방법을 제공해야 함.'
싱글톤이 하나의 인스턴스를 갖는 것이 확실하다면 클래스가 생성되고 초기화될 때 오직 하나의 단일 상태만 제공하는 것이 보장됨. 다시 말해, 실제로 싱글톤이 클래스에 제공하는 것은 모든 인스턴스에 걸쳐 단일한 공유 상태를 보장하는 방법임.

싱글톤의 첫 번째 요구사항은 약간 다른 형태로 바꿔 말할 수 있으며 최종 결과는 첫 번째 형식과 같음.
'클래스는 모든 인스턴스에 같은 초기 상태를 공유하기 위한 방법을 반드시 제공해야 함.'
'특정 메모리 위치에서 실제로 단 하나의 인스턴스를 보장하는 기법은 싱글톤을 달성하기 위한 방법 중 하나일 뿐임.'

#### Factory Pattern
'반복적이고 예측 가능한 방법으로 관련된 클래스의 인스턴스를 확실하게 생성할 수 있는 방법은 무엇입니까?'라는 질문은 팩토리 패턴으로 해결할 수 있음.

팩토리 패턴은 다른 클래스에 관련된 클래스들의 인스턴스 생성 문제를 해결하며, 단일 메서드를 통해 인스턴스의 생성을 구현함. 단일 메서드는 부모 팩토리 클래스에 정의돼(필요에 따라) 서브클래스에서 오버라이드됨.

팩토리 패턴은 클래스의 클라이언트(사용자)에게 클래스와 서브클래스의 인스턴스 생성을 위한 단일 진입점을 제공하는 편리한 방법을 제공함. 보통 팩토리 클래스의 특정 메서드, 즉 팩토리 메서드로 파라미터를 전달함.

#### Prototype Pattern
'객체를 인스턴스화하고 객체를 복사해, 유사한 수백개의 객체를 만드는 현명한 방법은 무엇인가?'라는 질문은 프로토타입 패턴을 통해 해결할 수 있음.

프로토타입 패턴은 프로그래머가 템플릿 인스턴스로 클래스의 인스턴스를 생성하고 프로토타입을 복사하거나 복제해 새로운 인스턴스를 생성할 수 있게 함. 프로토타입 패턴은 다음 상황일 때 가장 유용함.
- 시스템에서 인스턴스화된 클래스가 동적일 때, 즉 인스턴스가 구성의 일부로 명시되거나 런타임에 변경 가능한 경우
- 인스턴스가 초기 상태의 몇 가지 조합만 가질 때, 상태를 추적하고 매번 인스턴스를 인스턴스화하는 대신, 각 상태에 일치하는 프로토타입을 생성하고 이들을 복제하는 것이 더 편리함.

프로토타입 객체는 clone 메서드를 통해 자체 복제하는 기능을 지원함.

#### Builder Pattern
빌더 패턴은 객체의 표현과 객체의 생성을 분리함(조립). 따라서 같은 생성 프로세스가 서로 다른 표현을 만드는 데 사용될 수 있음.

빌더 패턴을 사용하면 각각 약간 다른 구축 프로세스나 조립 프로세스를 사용해 편리하게 다양한 타입이나 같은 클래스의 대표 인스턴스를 생성할 수 있음.

빌더 패턴은 공식적으로 Builder 객체에게 대상 클래스의 인스턴스를 만들도록 지시하는 Director 클래스를 사용함. 빌더의 다양한 타입(클래스)은 동일한 클래스의 약간 다른 변형들을 작성할 때 도움이 됨.

#### 빌더와 팩토리
빌더 패턴은 클래스의 인스턴스 조립 과정을 인스턴스의 생성과 분리함. 반면 팩토리는 같은 인터페이스를 사용해 같은 계층에 속한 다양한 하위 클래스의 인스턴스의 생성에 관련됨. 빌더는 마지막 단계로 빌드된 인스턴스를 반환함. 팩토리는 별도의 빌드 단계가 없기 때문에 인스턴스를 즉시 반환함.

#### 빌더와 프로토타입
빌더는 인스턴스를 생성하기 위해 내부적으로 프로토타입을 사용할 수 있음. 그 다음, 같은 빌더에서 나온 인스턴스들은 이 인스턴스에서 복제될 수 있음. 예를 들어 프로토타입의 인스턴스를 복제하기 위해서는 항상 프로토타입 메타클래스 중 하나를 사용하는 빌더 클래스를 만드는 것이 좋음.

#### 프로토타입과 팩토리
프로토타입 팩토리는 논의되고 있는 클래스들의 초기 인스턴스를 생성하기 위해, 내부적으로 팩토리 패턴을 사용할 수 있음.

#### 팩토리와 싱글톤
팩토리 클래스는 전통적인 프로그래밍 언어에서의 싱글톤임. 다른 옵션은 팩토리의 메서드를 클래스 메서드나 정적 메서드로 만드는 것. 따라서 팩토리 자체의 인스턴스를 작성할 필요가 없음. (보그 사용?)

### Structural Pattern
---
구조 패턴은 클래스나 객체들이 그들의 합보다 더 큰 구조를 형성하는 복잡한 결합과 관련이 있음. 더 큰 구조를 구별하는 두 가지 방법을 통해 구조적 패턴을 구현함.
- 상속을 사용해 클래스를 하나로 통합함. 이것은 정적인 방법.
- 런타임에 객체의 합성을 사용해 결합된 기능을 구현하는데, 더 동적이며 유연한 방법.

파이썬은 다중 상속을 지원하기 때문에 위의 두 가지 방법을 모두 구현할 수 있음. 파이썬은 동적인 속성을 지닌 언어이며 매직 메서드의 강력함을 사용하기 때문에 객체를 합성할 수 있으며 그 결과 생성된 메서드도 래핑할 수 있음. 따라서 파이썬을 사용하면 프로그래머는 구조적 패턴을 구현하는 관점에서 좋은 상황에 있게 됨.

의미 있는 구조로 객체를 합성하고 조립하는 것과 관련이 있으며 아키텍트와 개발자에게 재사용 가능한 동작을 제공함. 구조 패턴에서는 '전체가 그 부분의 합보다 더 크다'. 즉, 구조 패턴은 객체가 생성되고 객체를 통한 문제 해결의 다음 단계에서 발생함. 문제의 예는 다음과 같음.

#### Adapter Pattern
어댑터 패턴은 특정 인터페이스의 기존 구현을 클라이언트가 예상하는 또 다른 인터페이스로 래핑하거나 적용함. 어댑터는 Wrapper라고도 함.

#### Facade Pattern
파사드는 서브시스템의 다양한 인스턴스에 단일 인터페이스를 제공하는 구조적 패턴. 파사드 패턴은 시스템이 다양한 서브시스템으로 구성되고 서브시스템마다 자체 인터페이스를 갖고 있지만, 클라이언트에 관한 최상위 인터페이스로 기술돼야 하는 높은 수준의 기능을 제공할 때 유용함.

일상 생활에서 파사드의 고전적인 예는 자동차. 자동차는 엔진, 파워 트레인, 차축, 휠 어셈블리, 전자 장치, 조향 시스템, 브레이크 시스템 등의 여러 컴포넌트들로 구성돼 있음. 그러나 사람들은 자동차의 브레이크가 디스크 브레이크인지, 서스펜션이 코일 스프링인지 등에 관심이 없음. 자동차 제조업체가 자동차의 운행과 유지를 위한 파사드를 제공해, 복잡도를 감소시키고 쉽게 동작할 수 있는 간단한 서브시스템을 제공하기 때문임.
- 차에 시동을 걸기 위한 점화 시스템
- 차를 조정하는 조향 시스템
- 자동차를 제어하기 위한 클러치 브레이크 시스템
- 차의 동력과 속도를 관리하기 위한 기어와 트랜스미션 시스템 ...

파이썬 표준 라이브러리는 많은 모듈을 포함하고 있는데 이러한 모듈들은 파사드의 훌륭한 예. 파이썬 소스코드의 구문 분석과 컴파일에 관한 hook을 제공하는 컴파일러 모듈은 어휘 분석기(lexer), 구문 분석기(parser), 추상 구문 트리 생성기의 파사드임.

#### Proxy Pattern
'Wrapper, 상위 동작을 통해 객체와 객체의 메서드 접근을 제어하려면 어떻게 해야 하는가?' 해결.

프록시 패턴은 액세스 제어를 위해 또 다른 객체를 래핑함. 프록시 패턴의 몇 가지 사용 시나리오는 다음과 같음.
- 다른 네트워크에서 실제 리소스 대신 동작하는 클라이언트에 관련된 가상 리소스가 필요함. 예시로 원격 프록시가 있음.
- 자원에 관한 액세스를 제어/모니터링하는 경우, 예를 들어 네트워크 프록시와 인스턴스 카운팅 프록시가 있음.
- 직접 액세스가 보안 문제를 발생시키거나 자원 및 객체를 손상시켜 자원과 객체를 보호해야 할 때(보호 프록시). 리버스 프록시 서버를 예로 들 수 있음.
- 많은 비용이 드는 계산이나 네트워크 작업 결과의 액세스를 최적화 해 프록시 캐싱 같이 매번 계산이 수행되지 않도록 함.

프록시는 항상 프록시를 설정하는 객체의 인터페이스 즉, 대상을 구현해야 하는데 상속이나 합성을 통해 가능함. 파이썬에서 합성은 어댑터 패턴과 비슷하게 `__getattr__` 메서드를 오버라이딩해 더 확실하게 수행할 수 있음.

#### Composite pattern
'동시에 부분과 전체를 표현하기 위해 많은 컴포넌트로 구성된 객체를 같은 클래스를 사용해 어떻게 표현할 수 있는가? 예를 들어, 위젯 트리 같은 경우는?'

### Behavioral Pattern
---
행위 패턴들은 패턴의 복잡도와 기능성의 마지막 단계. 행위 패턴들은 시스템의 객체 수명주기에서 연대기의 마지막 부분에 나옴. 서로 상호작용하기 전에 더 큰 구조에 내장됨.

행위 패턴들은 객체 사이의 통신 모델과 상호작용을 캡슐화함. 패턴들은 런타임 때 따르기 어려운 복잡한 워크플로우를 기술할 수 있음. 일반적인 패턴은 상속보다 객체 합성을 선호하지만 시스템 안에 상호작용하는 객체는 별도의 클래스 계층 구조에 있어야 함.

행위 패턴은 객체의 런타임 시 상호 작용에 기인한 문제와 객체들이 책임을 분산시키는 방법을 해결함. 이 패턴은 클래스가 생성되고 더 큰 구조로 결합되면, 그 이후 단계에서 발생하는데 예는 다음과 같음.
- 다음 경우는 Median Pattern을 사용: 상호작용의 런타임 동적 특성을 향상시키기 위해 런타임 시 모든 객체가 서로 참조할 때 느슨한 결합의 사용을 보장함.
- 다음 경우는 Observer Pattern을 사용: 객체가 리소스의 상태 변경을 통보받기 원하지만 통보를 위해 자원의 polling은 원치 않을 때, 시스템에는 이런 객체의 인스턴스가 많이 있을 수 있음.

#### Iterator Pattern
이터레이터는 기본 객체를 노출시키지 않고 컨테이너 객체의 요소에 순차적으로 액세스하는 방법을 제공함. 다시 말해, 이터레이터는 컨테이너 객체에 걸쳐 반복하는 단일 메서드를 제공하는 프록시.

파이썬 이터레이터는 매직 메서드 `__iter__`를 구현하는 모든 객체이며 이터레이터 인스턴스를 반환하는 함수 `iter`에 대응함.

#### Observer Pattern
옵저버 패턴은 객체를 분리하지만 동시에 한 객체의 집합(구독자)이 또 다른 객체(게시자)의 변경을 추적할 수 있게 함. 이것은 상호작용을 유지하면서 일대다 의존성과 참조를 방지함. 옵저버 패턴은 Pub-Sub 패턴이라고도 함.

#### State Pattern
상태 패턴은 다른 클래스(상태 객체)에 있는 객체의 내부 상태를 캡슐화함. 객체는 내부적으로 캡슐화된 상태 객체를 다른 값으로 전환해 상태를 변경함.

상태 객체와 유사한 부류인 유한 상태 머신(Finite State Machine)은 프로그래머에게 복잡한 코드를 요구하지 않으면서 객체의 다양한 상태에 걸쳐 매끄러운 상태 전이를 구현할 수 있게 함. 파이썬은 객체 클래스에 대한 매직 속성인 `__class__` 속성을 갖고 있기 때문에 파이썬에서 상태 패턴을 쉽게 구현할 수 있음.

파이썬에서 `__class__` 속성은 인스턴스의 딕셔너리에서 수정할 수 있음. 이것은 인스턴스가 동적으로 인스턴스의 클래스를 변경할 수 있게 하며 파이썬에서 상태 패턴을 구현할 때 활용할 수 있음.